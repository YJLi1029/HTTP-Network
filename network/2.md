# 간단한 프로토콜 HTTP

# HTTP

## 클라이언트와 서버 간에 통신

리소스를 요구하는 쪽이 클라이언트, 제공하는 쪽이 서버

HTTP는 클라이언트와 서버 간의 역할을 명확하게 구별하고 있다.

## 리퀘스트와 리스폰스를 교환하여 성립

클라이언트로부터 리퀘스트가 송신되고, 그 결과가 서버로부터 리스폰스로 되돌아옴.

→ 반드시 클라이언트로부터 통신이 시작!! 서버 측이 리퀘스트를 수신하지 않고 리스폰스 하는 경우는 없다.

(ex)

```html
GET /index.html HTTP /1.1
Host : www.qwer.com
```

GET : 서버에 요구하는 종류. 메소드.

/index.html : 요구 대상인 리소스. 리퀘스트 URI.

HTTP /1.1 : 클라이언트 기능을 식별하기위한 HTTP 버전 번호.

→ HTTP 서버 상에 있는 /index.html 라는 리소스가 필요하다는 리퀘스트. 

리퀘스트 메시지는 메소드, URI, 프로토콜 버전, 옵션 리퀘스트 헤더 필드, 엔티티로 구성.

리퀘스트를 받은 서버는 리퀘스트 내용을 처리한 결과를 리스폰스로 클라이언트에 되돌려 준다.

```html
HTTP /1.1 200 OK
Date: Tue, 10 Jul 2020 15:10:23 GMT
Content-Length: 362
Content-Type: text/html

<html>
...
```

HTTP /1.1 : 서버의 HTTP 버전

200 OK : 리퀘스트의 처리 결과를 나타내는 상태 코드와 설명

<html>~ : 빈줄로 위와 구분. 바디라고 불리는 리소스 본체.

리스폰스 메시지는 프로토콜 버전, 상태 코드(리퀘스트 성공여부를 나타내는 숫자코드), 그 상태 코드를 설명한 프레이즈, 옵션의 리스폰스 헤더 필드와 바디.



## 상태를 유지하지 않는 프로토콜

HTTP는 상태를 계속 유지하지 않는 스테이트리스(stateless)  프로토콜.

리퀘스트와 리스폰스를 교환하는 동안에 상태(status)를 관리하지 않음. 결국 HTTP 프로토콜 레벨에서는 이전에 보냈던 리퀘스트나 이미 되돌려준 리스폰스에 대해서는 전혀 기억하지 않음.

그러나, 웹이 진화함에 따라 스테이트리스 특성만으로는 처리하기 어려운 일이 증가. ex) 쇼핑몰에 로그인했을 때 다른 페이지로 이동하더라도 로그인 상태를 유지해야 함.

HTTP/1.1은 상태를 유지하지 않는 프로토콜이기 때문에 쿠키(Cookie)를 도입.



## 리퀘스트 URI로 리소스 식별

HTTP는 URI를 사용하여 인터넷 상의 리소스를 지정. 인터넷 상의 어떤 장소에 있는 리소스도 호출할 수 있다.

리퀘스트 URI를 지정하는 방법

- 모든 URI를 리퀘스트 URI에 포함

    ```html
    GET [http://qwer.com/index.htm](http://qwer.com/index.htm) HTTP/1.1
    ```

- Host 헤더 필드에 네트워크 로케이션을 포함

    ```html
    GET [http://index.htm](http://qwer.com/index.htm) HTTP/1.1
    Host: qwer.com
    ```



## HTTP 메소드로 서버에 임무 부여

HTTP/1.1에서 사용할 수 있는 메소드

- GET : 리소스 획득
    - 리퀘스트 URI로 식별된 리소스를 가져올 수 있도록 한다.
    - 가져올 리소스 내용은 지정된 리소스를 서버가 해석한 결과. ex) 리소스가 텍스트 : 그대로 반환, 리소스가 프로그램 : 실행해서 출력된 내용 반환
- POST : 엔티티 전송
    - GET과 기능이 유사하지만 일반적으로 GET 보다는 POST를 사용해서 엔티티 전송.
- PUT : 파일 전송
    - FTP에 의한 파일 업로드와 같이, 리퀘스트 중에 포함된 엔티티를 리퀘스트 URI로 지정한 곳에 보존하도록 요구
    - 단, 인증 기능이 없어 보안 상의 문제가 생길 수 있기에 일반적인 웹사이트에서는 사용하지 않음.
    - 웹 애플리케이션 등에 의한 인증 기능과 짝을 이루는 경우나 REST와 같이 웹끼리 연계하는 설계 양식을 사용할 때 이용하는 경우가 있음.
- HEAD : 메시지 헤더 취득
    - GET과 같은 기능이지만, 메시지 바디는 돌려주지 않음.
    - URI  유효성과 리소스 갱신 기간을 확인하는 목적 등으로 사용.
- DELETE : 파일 삭제
    - PUT 메소드와는 반대로 동작. 리퀘스트 URI로 지정된 리소스의 삭제를 요구.
    - 단, PUT과 마찬가지로 보안상의 문제가 있기 때문에 일반적인 웹사이트에서는 사용하지 않음.
- OPTIONS : 제공하고 있는 메소드를 조사
    - 리퀘스트 URI로 지정한 리소스가 제공하고 있는 메소드를 조사하기 위해 사용.
- TRACE : 경로 조사
    - Web 서버에 접속해서 자신에게 통신을 되돌려 받는 루프백을 발생시킴.
    - 리퀘스트를 보낼 때 'Max-Forwards'라는 헤더 필드에 수치를 포함시켜 서버를 통과할 때마다 그 수치를 줄여가다 0이 된 곳을 끝으로 리퀘스트를 마지막으로 수신한 곳에서 200 OK 리스폰스를 되돌려 준다.
    - 클라이언트는 TRACE 메소드를 이용하여 리퀘스트를 보낸 곳에 어떤 리퀘스트가 가공되어 있는지 등을 조사할 수 있음.
    - 단, XST와 같은 공격을 일으키는 보안 상의 문제도 있기 때문에 보통은 사용되지 않음.
- CONNECT : 프록시에 터널링 요구
    - 프록시에 터널 접속 확립을 요함으로써, TCP 통신을 터널링 시키기 위해 사용됨.
    - 주로 SSL과 TLS 등의 포로토콜로 암호화된 것을 터널링 하기 위해 사용됨.

메소드는 리소스에 어떠한 행동을 하기 원하는지를 지시하기 위해 존재한다.   


※ 메소드는 대소문자를 구분하기 때문에 대문자로 써줘야 한다.



## 지속 연결로 접속량을 절약

HTTP 초기 버전에서는 HTTP 통신을 한 번 할때마다 TCP에 의해 연결을 종료할 필요가 있었음.

그러나, 다량의 이미지를 포함한 문서 등이 늘어나게 되며 리퀘스트를 보낼 때마다 TCP 연결과 종료를 하게 되면 쓸모없는 일이 발생되어 통신량이 늘어나게 됨.

이를 해결하기 위해, 지속 연결(Presistent Connections)라는 방법을 고안. 어느 한쪽이 연결을 종료하지 않는 이상 TCP 연결을 계속 유지한다.

- 서버에 대한 부하가 줄어듦
- 리퀘스트와 리스폰스가 빠르게 완료되어 웹페이지를 빨리 표시할 수 있음
- 파이프라인화를 가능하게 하여 리스폰스를 기다리지 않고 바로 다음 리퀘스트를 보낼 수 있게 됨.



## 쿠키를 사용한 상태 관리

HTTP는 앞에서 얘기했듯이 스테이트리스 프로토콜이다. 그렇기에 과거 상태를 근거로 현재의 리퀘스트를 처리하기 위해서 스테이트리스 프로토콜은 그대로 둔 채 쿠키(Cookie)라는 시스템을 도입하였다.

- 쿠키 : 리퀘스트와 리스폰스에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하기 위한 시스템.

서버에서 리스폰스로 보내진 Set-Cookie라는 헤더 필드에 의해 쿠키를 클라이언트에 보존하게 됨. 

다음 번에 클라이언트가 같은 서버로 리퀘스트를 보낼 때, 자동으로 쿠키 값을 넣어서 송신한다.

서버는 클라이언트가 보내온 쿠키를 확인해서 어느 클라이언트가 접속했는지 체크하고 서버 상의 기록을 확인해서 이전 상태를 알 수 있다.

(ex)

리퀘스트(쿠키를 가지고 있지 않은 상태)

```html
GET /reader/ HTTP /1.1
Host : www.qwer.com
```

헤더 필드에 쿠키는 없다.

리스폰스(서버가 쿠키를 발행)

```html
HTTP /1.1 200 OK
Date : Wed. 05 Aug 2020 16:43:11 GMT
Server: Apache
<Set-Cookie: sid=135432346767; path=/;expires=Thur, => 06-Sep-20 16:43:11 GMT>
Content-Type: text/plain; charset=UTF-8
```

리퀘스트(보관하고 있던 쿠키를 자동 송신)

```html
GET /image/ HTTP /1.1
Host: www.qwer.com
Cookie: sid=135432346767
```