# 3. HTTP 메시지


웹 서버와 웹 브라우저 사이에 전달되는 데이터.   
리퀘스트 측은 리퀘스트 메시지, 리스폰스 측은 리스폰스 메시지라고 부른다.   


# 리퀘스트 메시지와 리스폰스 메시지의 구조

리퀘스트 라인 : 리퀘스트에 사용하는 메소드, 리퀘스트 URI, 사용하는 HTTP 버전 포함

상태 라인 : 리스폰스 결과를 나타내는 상태 코드, 설명, 사용하는 HTTP 버전 포함

헤더 필드 : 리퀘스트와 리스폰스의 여러 조건과 속성 등을 나타내는 각종 헤더 필드가 포함됨

- 일반, 리퀘스트, 리스폰스, 엔티티 4종류의 헤더 필드가 있다.

그 외 : HTTP의 RFC에 없는 헤더 필드(쿠키 등)가 포함되는 경우



## 리퀘스트 메시지의 구조

- 리퀘스트 라인
- 리퀘스트 헤더 필드
- 일반 헤더 필드
- 엔티티 헤더 필드
- 그 외



## 리스폰스 메시지의 구조

- 상태 라인
- 리스폰스 헤더 필드
- 일반 헤더 필드
- 엔티티 헤더 필드
- 그 외


※ HTTP로 데이터를 전송할 경우 그대로 전송할 수도 있지만, 전송할 때 인코딩(변환)을 하면 전송 효율을 높일 수 있다.   
    단, 인코딩 처리를 해야 하기 때문에 CPU 등의 리소스는 많이 소비하게 된다.



## 메시지 바디 vs 엔티티 바디

※ 메시지(message)

HTTP 통신의 기본 단위. 옥텟 시퀀스로 구성되고 통신을 통해서 전송된다.

※ 엔티티(entity)

리퀘스와 리스폰스의 페이로드(payload)로 전송되는 정보. 엔티티 헤더 필드와 엔티티 바디로 구성됨.

메시지 바디는 리퀘스트와 리스폰스에 관한 엔티티 바디를 운반한다. 기본적으로 둘은 같지만 전송 코딩이 적용된 경우에는 엔티티 바디의 내용이 변하게 된다.



## 콘텐츠 코딩

우리가 흔히 메일을 보낼 때 첨부파일의 용량을 줄이기 위해 파일을 압축하는 것처럼, HTTP에서도 이와 같은 기능이 있다.

이를 콘텐츠 코딩(content codings)라고 하는데, 엔티티 정보를 유지한 채로 압축하는 엔티티 인코딩을 가리킨다. 콘텐츠 코딩된 엔티티는 수신한 클라이언트 측에서 디코딩한다.

주요 콘텐츠 압축

- gzip(GNU zip)
- compress(UNIX 표준 압축)
- deflate(zlib)
- identity(인코딩 없음)



## 청크 전송 코딩

엔티티 바디의 전송이 완료되지 않으면 브라우저에 표시되지 않는다. 그래서 사이즈가 큰 데이트를 전송하는 경우 데이터를 분할해서 조금씩 표시할 수 있다.

청크 전송 코딩(chunked tranfer coding)은 엔티티 바디를 청크로 분할한다.

청크 전송 코딩된 엔티티 바디는 수신한 클라이언트 측에서 원래의 엔티티 바디로 디코딩한다.



# 멀티파트

우리가 메일을 보낼 때 MIME 기능 안의 확장 사양인 멀티파트를 이용하여 첨부파일이나 본문을 첨부하여 보낼 수 있는 것처럼, HTTP도 멀티파트를 이용해 하나의 메시지 바디 내부에 엔티티를 여러 개 포함해 보낼 수 있다. 주로 이미지, 텍스트 파일 등을 업로드할 때 사용된다.

(ex)

- multipart/form-data

    Web 폼에서 파일 업로드에 사용된다.

- multipart/byteranges

    상태 코드 206(partial content) 리스폰스 메시지가 복수 범위의 내용을 포함할 때 사용된다.



# 레인지 리퀘스트

오늘날처럼 광대역 네트워크를 이용하기 전에는 다운로드 중 커넥션이 끊어지면 처음부터 다시 다운로드를 해야 하기 때문에 대용량 이미지와 데이터를 다운로드하기 어려웠다. 이 때문에 리줌(resume)이라는 기능으로 이전에 다운로드한 지점부터 다운로드를 재개할 수 있게 하였다.

이를 위해서는 엔티티의 범위를 지정해서 다운로드를 해야 하는데, 이처럼 범위를 지정하여 리퀘스트 하는 것을 레인지 리퀘스트(range request)라고 한다.

레인지 리퀘스트를 위해서는 전체 10,000 바이트 정도 크기의 리소스에서 5,001~10,000 바이트 범위만들 리퀘스트 할 수 있다.

바이트 레인지는 다음과 같이 지정할 수 있다.

- 5,001~10,000바이트

```html
Range: bytes = 5001-10000
```

- 5,001 바이트 이상

```html
Range: bytes = 5001-
```

- 처음부터 3,000바이트까지, 그리고 5,000~7,000 바이트까지의 복수 범위

```html
Range: bytes = -3000, 5000-7000
```

레인지 리퀘스트에 대한 리스폰스는 상태 코드 206 partial content라는 리스폰스 메시지로 되돌아온다. 또한, 복수 범위의 레인지 리퀘스트에 대한 리스폰스는 nultipart/byteranges로 리스폰스가 되돌아온다.

서버가 레인지 리퀘스트를 지원하지 않는 경우에는 상태 코드 200 OK라는 리스폰스 메시지로 완전한 엔티티가 되돌아온다.



# 콘텐츠 네고시에이션

같은 콘텐츠(내용)이지만 여러 개의 페이지를 가진 경우와 같은 구조를 콘텐츠 네고시에이션 이라고 부른다. 예를 들어, 구글 페이지가 한글판과 영어판 두 가지로 표현되는 것이 있다.

이는 서로 다른 언어를 주로 사용하는 브라우저가 같은 URI에 액세스할 때 각각 영어판, 한글판으로 웹 페이지를 표시하는 것이다.

- 클라이언트와 서버가 제공하는 리소스의 내용에 대해서 교섭하는 것.
- 클라이언트에게 더욱 적합한 리소스를 제공하기 위한 구조.
- 제공하는 리소스를 언어, 문자세트, 인코딩 방식 등의 기준으로 판단.(헤더필드)



## 콘텐츠 네고시에이션의 종류

- 서버 구동형 네고시에이션(Server-driven Negotiation)
    - 서버 측에서 콘텐츠 네고시에이션을 하는 방식.
    - 서버 측에서 리퀘스트 헤더 필드의 정보를 참고해서 자동적으로 처리한다.
    - 단, 브라우저가 보내는 정보를 근거로 하기에 실제 유저에게 적절한 것이 선택되었다고는 할 수 없다.
- 에이전트 구동형 네고시에이션(Agent-driven Negotiation)
    - 클라이언트 측에서 네고시에이션을 하는 방식.
    - 브라우저에 표시된 선택지 중에서 유저가 수동으로 선택.
    - JavaScript 등을 이용해 웹페이지에서 자동적으로 선택하는 경우도 있음.
- 트랜스페런트 네고시에이션(Transparent Negotiation)
    - 서버 구동형과 에이전트 구동형을 혼합한 형태로, 서버와 클라이언트가 각각 콘텐츠 네고시에이션을 하는 방식